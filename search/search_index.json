{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"MajorDom Documentation","text":"<p>Info</p> <p>MajorDom's public documentation is still in progress and will be available soon after the Kickstarter campaign. Meanwhile, you can get more information about MajorDom at majordom.io. Don't forget to subscribe to our newsletter to get notified about status of the project, kickstarter campaign, documentation release and more.</p>"},{"location":"architecture/","title":"Architecture Overview","text":"<p>MajorDom consists of several key components: devices, hub, cloud, bridge, mobile application, and voice assistant.</p> <p>Devices play a crucial role in the system as they enable control over physical parts of the home. They communicate using radio modules and the \u201cMerlin\u201d protocol that receive commands from the hub, and transmit events back to it.</p> <p>The hub is the central element of the system. It manages the devices and coordinates their operations. The hub holds the main database with information about users, home, rooms, and devices. Through a local HTTP server and WS server, the hub provides an API for interacting with the database and for high-level control of devices.</p> <p>The cloud is the server-side component and plays a vital role in user authentication. It stores the database of users, homes, hubs, and their access rights. Device models with a list of parameters and a firmware update system are also stored in the cloud.</p> <p>The bridge is a WS server that provides communication between the hub and remote user over the internet. It enables sending commands and receiving information from the hub without being within the home's local network.</p> <p>The system can have multiple bridges located in different places. Clients select the nearest or least loaded bridge to minimize communication delays.</p> <p>One of the main features of the MajorDom is its fault tolerance. Despite the collapse of one or multiple bridges, the system perseveres and maintains its functionality. The remaining available bridges take on the tasks of the inactive bridges, ensuring uninterrupted data exchange between the hub and clients.</p> <p>Even a complete loss of internet connection on the hub is not a problem. All the logic and command processing occur locally, ensuring independence from the internet connection and maintaining the ability to control devices within the local network. However, such scenarios are rare since the hub can be simultaneously connected via Wi-Fi and an Ethernet cable, and future support for cellular network will be added.</p> <p>Smart home control is achieved through a mobile application that provides a user-friendly interface. However, in practice, the role of the mobile application often reduces to system configuration, while day-to-day device management is carried out using automatic scenarios and the voice assistant.</p> <p>Like the hub, the voice assistant can work completely offline, ensuring security, privacy, and reliability of use.</p>"},{"location":"custom-device-legacy/","title":"Custom Device (legacy)","text":""},{"location":"custom-device-legacy/#create-a-custom-device-model","title":"Create a Custom Device Model","text":"<ol> <li>Open the MajorDom mobile app.</li> <li>Navigate to <code>Settings</code> and enable <code>Developers Mode</code>.</li> <li>Return to the home screen and tap the <code>+</code> button located in the top-right corner.</li> <li>Alongside the existing options \"Create a Room\" and \"Add a Device\", a new option, \"Create a Device Model\", will now be available.</li> <li>Choose <code>Create a Device Model</code>.</li> <li>Provide a name for your custom device model and define a set of parameters. Custom parameters can also be added.</li> <li>After creation, the device model and its parameters will be stored on the Hub.</li> <li>You can now use this custom device model with new devices in your home by specifying the device model UUID in the sketch and implementing parameter handling.</li> </ol>"},{"location":"custom-device-legacy/#write-device-sketch","title":"Write Device Sketch","text":""},{"location":"custom-device-legacy/#using-merlin-framework","title":"Using Merlin Framework","text":""},{"location":"custom-device-legacy/#merlin24-c","title":"Merlin24 C++","text":"<p>Merlin24 works with low-power, long-range nrf24l01 radio modules operating on the 2.4GHz band.</p> <p>Here's an example sketch for controlling a relay:</p> <pre><code>#include &lt;Merlin24.h&gt;\n\n// Define pin numbers\n#define RELAY_PIN 3\n#define BUTTON_PIN 4\n\n// Variables to store the state\nbyte relay_state = LOW;\nbyte last_button_state = HIGH; // Assuming pull-up\n\n// Define constants for function codes\n#define RELAY_PARAMETER 1\n\n// Initialize Merlin24 object with device model uuid and parameter value handler function\nMerlin24 device(\"10359220-c504-40d0-bed7-f254cc85e75c\", [](byte parameter_index, byte value) {\n    switch (parameter_index) {\n        case RELAY_PARAMETER:\n            // toggle the relay and save new state\n            relay_state = value;\n            digitalWrite(RELAY_PIN, value);\n            break;\n        // You can add more cases here for other parameters\n        default:\n            break; // Handle unknown function code here (optional)\n    }\n});\n\nvoid setup() {\n    pinMode(RELAY_PIN, OUTPUT);\n    pinMode(BUTTON_PIN, INPUT_PULLUP);\n}\n\nvoid loop() {\n    /*\n        tick() is required for Merlin24 to work\n        it should be called as often as possible\n        avoid delays and other blocking code\n    */\n    device.tick();\n\n    /* \n        Toggle the relay on the button press\n        Just an example, in real life you would probably want to debounce the button\n    */\n\n    // Read the button state\n    byte current_button_state = digitalRead(BUTTON_PIN);\n\n    // Check for button press (LOW when pressed because of pull-up resistor)\n    if (last_button_state == HIGH &amp;&amp; current_button_state == LOW) {\n\n        // Toggle the relay, save the state and send it to hub\n        digitalWrite(RELAY_PIN, relay_state);\n        relay_state = !relay_state;\n        device.send(RELAY_PARAMETER, relay_state);\n    }\n\n    // Update last button state\n    last_button_state = current_button_state;\n}\n</code></pre>"},{"location":"custom-device-legacy/#merlinwifi-merlinhttp-c","title":"MerlinWiFi (MerlinHttp) C++","text":"<p>The <code>MerlinHttp</code> class provides a way to connect your device to a hub over HTTP, making it a great choice for devices that require internet access or advanced capabilities. It is particularly suitable for ESP32/ESP8266 boards.</p> <p>To switch from <code>Merlin24</code> to <code>MerlinHttp</code>, all you need to do is change the included header and initialize <code>MerlinHttp</code> instead. In most cases, this should be sufficient.</p> <pre><code>#include &lt;MerlinHttp.h&gt;\n// ... (other parts remain unchanged)\nMerlinHttp device(\"10359220-c504-40d0-bed7-f254cc85e75c\", [](byte parameter_index, byte value) {\n// ... (other parts remain unchanged)\n</code></pre>"},{"location":"custom-device-legacy/#manually-merlinhttp-protocol-overview","title":"Manually (MerlinHttp Protocol Overview)","text":"<p>If you want to use other technologies, hardware, or software\u2014e.g., a Raspberry Pi with a Python program and FastAPI server\u2014you can still communicate with the Hub over HTTP by implementing the required endpoints manually. Below is an overview of how the Hub-to-Device and Device-to-Hub communication occurs.</p>"},{"location":"custom-device-legacy/#hub-to-device-communication","title":"Hub-to-Device Communication","text":"<p>Your device should host an HTTP server and expose the following RESTful API endpoints:</p> <p><code>GET /api/v1/merlin</code>: Used by the Hub to get current device state Reponse Payload: <pre><code>[\n    {\n    \"index\": \"&lt;parameter_index: int in 0...255&gt;\",\n    \"value\": \"&lt;parameter_value: base64 encoded value&gt;\"\n    },\n]\n</code></pre></p> <p><code>POST /api/v1/merlin</code>: Used by the Hub to send parameter updates to the device.</p> <p>Request Payload: <pre><code>{\n\"index\": \"&lt;parameter_index: int in 0...255&gt;\",\n\"value\": \"&lt;parameter_value: base64 encoded value&gt;\"\n}\n</code></pre></p> <p><code>POST /api/v1/credentials</code>: Used by the Hub to send network and authentication credentials to the device on initial setup.</p> <p>Request Payload: <pre><code>{\n\"ssid\": \"&lt;Wi-Fi SSID&gt;\",\n\"psk\": \"&lt;Wi-Fi Password&gt;\",\n\"hub_host\": \"&lt;Hub Host Address&gt;\",\n\"token\": \"&lt;JWT Token&gt;\"\n}\n</code></pre></p>"},{"location":"custom-device-legacy/#device-to-hub-communication","title":"Device-to-Hub Communication","text":"<p>To communicate with the Hub, the device should make HTTP requests to the Hub's  API endpoints:</p> <p>Send Parameter Updates: <code>{hub_host}/api/merlin/state</code></p> <p>Request Payload: <pre><code>{\n\"index\": \"&lt;parameter_index: int in 0...255&gt;\",\n\"value\": \"&lt;parameter_value: base64 encoded value&gt;\"\n}\n</code></pre></p> <p>Update Device Host (ip:port) Address: <code>{hub_host}/api/merlin/host</code></p> <p>Request Payload: <pre><code>{\n\"host\": \"&lt;device_host_address&gt;\"\n}\n</code></pre></p>"},{"location":"custom-device-legacy/#authorization","title":"Authorization","text":"<p>Authentication is implemented using a long-lived JWT token included in the <code>Authorization</code> header of each HTTP request:</p> <pre><code>\"Authorization\": \"Bearer &lt;JWT Token&gt;\"\n</code></pre>"},{"location":"custom-device-legacy/#discovery","title":"Discovery","text":"<p>To make a device discoverable, setup zeroconf service of type <code>_majordom-device._tcp</code> and specify the port of the merlin interface server. Now Hub can find the device in your LAN.</p>"},{"location":"custom-device-legacy/#parameter-value-types","title":"Parameter (Value) Types","text":"<p>Current available types:</p> <pre><code>class ParameterType(str, Enum):\n    # Base types\n    integer = \"integer\"  # uint8\n    decimal = \"decimal\"  # uint8 casting from [0, 255] to [0, 1]\n    boolean = \"boolean\"  # real one-bit integer\n    enum = \"enum\"        # uint8 with string_representation\n    string = \"string\"    # string\n\n    humidity = \"humidity\"          # decimal;\n    temperature = \"temperature\"    # float8;\n    color_temperature = \"color_temperature\"  # Kelvin, decimal; 0.5 is white\n    rgb = \"rgb\"                    # hue wheel angle, decimal; TODO: uint8[3];\n    volume = \"volume\"              # decimal;\n    timeinterval = \"timeinterval\"  # seconds, int32;\n\n    button = \"button\"              # None, just a button\n</code></pre> <p>Example of decoding:</p> <pre><code>class DeviceParameter(Parameter): # pydantic.BaseModel\n    value: bytes\n\n    class Config:\n        json_encoders = {\n            bytes: lambda v: base64.b64encode(v).decode()\n        }\n\n    @validator('value', pre=True)\n    def base64_decode(cls, value: str) -&gt; bytes:\n        if value is not None and isinstance(value, str):\n            return base64.b64decode(value)\n        return value\n\n    @property\n    def decoded_value(self) -&gt; int | float | bool | str | bytes:\n        match self.value_type:\n\n            case ParameterType.integer | ParameterType.enum:\n                return max(0, min(int.from_bytes(self.value, 'big'), 255)) # int as uint8 in [0, 255]\n\n            case ParameterType.timeinterval:\n                return int.from_bytes(self.value, 'big') # just int\n\n            case ParameterType.decimal | ParameterType.humidity | ParameterType.temperature | ParameterType.color_temperature | ParameterType.rgb | ParameterType.volume:\n                return max(0, min(int.from_bytes(self.value, 'big'), 255)) / 255 # float in [0, 1] mapped from uint8 in [0, 255]\n\n            case ParameterType.boolean:\n                return bool(self.value[0])\n\n            case ParameterType.string:\n                return self.value.decode('utf-8') # utf-8 is default but explicit is better than implicit\n\n            case ParameterType.button:\n                return b'\\x00'\n\n            case _:\n                return self.value\n</code></pre>"},{"location":"device-integration/","title":"Device Integration","text":""},{"location":"device-integration/#majordom-device-integration-guide","title":"MajorDom Device Integration Guide","text":""},{"location":"device-integration/#overview","title":"Overview","text":"<p>To integrate a device into MajorDom, you need to implement a subclass of <code>AbstractController</code> - which provides an essential standartized interface for MajorDom to interact with your device(s). To share runtime information with MajorDom, you should call respective methods of <code>self.dependencies.output</code> (defined as <code>ControllerOutput</code>).</p>"},{"location":"device-integration/#storing-data","title":"Storing Data","text":"<p><code>self.dependencies.make_device_repository</code> provides and async context manager for device repository which allows you to perform CRUD operations on devices. You can store arbitrary data in <code>Device.integration_data</code> or <code>Parameter.integration_data</code> fields as long as they are JSON serializable. You can use custom subclasses of <code>Device</code> and <code>Parameter</code> to override <code>integration_data</code> type annotation, for example, with another pydantic model for hassle-free automatic serialization and deserialization.</p>"},{"location":"device-integration/#checklist","title":"Checklist","text":"<ul> <li>discovery of new devices (<code>self.dependencies.output.controller_did_receive_discovery</code> is called)</li> <li>discovery of devices already paired to Hub, for example, in cases of device's or Hub's reboot (<code>self.dependencies.output.controller_did_connect_device</code> is called)</li> <li>device pairing (<code>async def pair_device</code> is implemented)</li> <li>device schema is properly mapped: device info, parameters list, and each parameter's metadata are translated to MajorDom language</li> <li>Hub -&gt; Device control (<code>async def send_command</code> is implemented)</li> <li>Device -&gt; Hub device event subscription handling (<code>self.dependencies.output.controller_did_receive_device_events</code> is being called)</li> <li><code>identify</code>, <code>unpair</code>, <code>fetch</code> methods are implemented</li> <li>graceful shutdown in <code>def stop</code> method</li> </ul>"},{"location":"device-integration/#abstractcontroller-overview","title":"AbstractController Overview","text":"<pre><code>from __future__ import annotations\n\nfrom abc import ABC, abstractmethod\nfrom dataclasses import dataclass\nfrom typing import AsyncContextManager, Callable, Protocol, Type\nfrom uuid import UUID\n\nfrom typing_extensions import Iterable\nfrom zeroconf.asyncio import AsyncZeroconf\n\nfrom majordom_hub.repository.device_repository import DeviceRepository\nfrom majordom_hub.schemas.automation.events import DeviceParameterChangedEvent\nfrom majordom_hub.schemas.command import DeviceCommand\nfrom majordom_hub.schemas.device import CredentialsValue, Device, Discovery, Parameter\n\n\nclass ControllerOutput(Protocol):\n\n    async def controller_did_receive_discovery(self, controller: AbstractController, discovery: Discovery): ...\n\n    async def controller_did_connect_device(self, controller: AbstractController, device_id: UUID): ...\n\n    async def controller_did_receive_device_events(self, controller: AbstractController, event: Iterable[DeviceParameterChangedEvent]): ...\n\nclass AbstractController[TDevice: Device, TParameter: Parameter](ABC):\n\n    @dataclass\n    class Dependencies:\n        output: ControllerOutput\n        make_device_repository: Callable[[], AsyncContextManager[DeviceRepository]]\n        zeroconf: AsyncZeroconf\n        register_zeroconf: Callable[[set[str]], None]\n\n    def __init__(self, dependencies: Dependencies):\n        self.dependencies = dependencies\n\n    # Abstract - to be implemented\n\n    @property\n    @abstractmethod\n    def discoveries(self) -&gt; dict[UUID, Discovery]:\n        return {}\n\n    @property\n    @abstractmethod\n    def name(self) -&gt; str:\n        return ''\n\n    @property\n    def device_type(self) -&gt; Type[TDevice]:\n        '''Override this property to use your own Device subclass for auto parsing'''\n        return Device\n\n    @property\n    def parameter_type(self) -&gt; Type[TParameter]:\n        '''Override this property to use your own Parameter subclass for auto parsing'''\n        return Parameter\n\n    @abstractmethod\n    async def start(self): \n        '''Setup the integration here'''\n        ...\n\n    @abstractmethod\n    async def stop(self): \n        '''Gracefully cleanup and shutdown the integration'''\n        ...\n\n    @abstractmethod\n    async def pair_device(self, discovery: Discovery, credentials: CredentialsValue | None): ...\n\n    @abstractmethod\n    async def unpair(self, device: TDevice): ...\n\n    @abstractmethod\n    async def identify(self, device: TDevice): ...\n\n    @abstractmethod\n    async def fetch(self, device: TDevice): ...\n\n    @abstractmethod\n    async def send_command(self, command: DeviceCommand, device: TDevice, parameter: TParameter): ...\n</code></pre>"},{"location":"device-integration/#data-models","title":"Data Models","text":"<pre><code># Pairing\n\nclass CredentialsType(str, Enum):\n    code = \"code\"  # pin, e.g. 1234-123-1234 (matter) or 123-45-678 (homekit)\n    secret = \"secret\"  # for example, AES key like in esphome\n    qr = \"qr\"  # raw qr data;\n    none = \"none\"\n    # can be extended if needed\n\n    def with_mask(self, code_mask: str) -&gt; CredentialsType:\n        \"\"\"\n        mask format: D as digit placeholder, other symbols like dashes remain unchanged,\n        for example \"DDD-DD-DDD\" for \"123-45-678\"\n        Can be extended if needed.\n        \"\"\"\n        self.code_mask = code_mask\n        return self\n\ntype CredentialsValue = str\n\nclass Discovery(Base):\n    # technical\n    id: UUID\n    integration: NonEmptyStr\n    credentials: CredentialsType\n    expiration: datetime | None = None\n    # for UX\n    transport: NonEmptyStr\n    device_manufacturer: str | None\n    device_name: NonEmptyStr\n    device_category: str | None\n    device_icon: str | None\n\n\n# Device\n\n\nclass DeviceInfo(DevicePatch):\n    name: str\n    note: str = \"\"\n    icon: str | None = None\n    category: str | None = None\n    room_id: UUID\n\n    id: UUID\n    transport: str\n    integration: str\n    manufacturer: str | None\n\n    last_seen: datetime | None = None\n    available: bool = False\n\n\nclass Device(DeviceInfo):\n    integration_data: SerializeAsAny[dict | Base] = Field(default_factory=Base)\n\n\nclass DeviceDataModel(DeviceInfo):\n    parameters: list[Parameter]\n\n\nclass DeviceState(DeviceInfo):\n    parameters: list[ParameterState]\n\n# Parameters\n\nclass ParameterDataType(StrEnum):\n    none = \"none\" # e.g. button\n    # numeric\n    bool = \"bool\"\n    integer = \"integer\"\n    decimal = \"decimal\" # python float\n    enum = \"enum\" # integer with string_representation\n    # data\n    string = \"string\"\n    data = \"data\" # binary data, base64 encoded at high level\n    # can be extended if needed\n\nclass ParameterUnit(StrEnum):\n    plain = \"plain\" # raw data type\n    percentage = \"percentage\"\n    # time\n    second = \"second\"\n    hertz = \"hertz\"\n    # kinematic\n    kilogram = \"kilogram\"\n    arcdegree = \"arcdegree\"\n    meters = \"meters\"\n    mps = \"mps\" # meters per second, speed\n    mps2 = \"mps2\" # meters per second squared, acceleration\n    rpm = \"rpm\" # revolutions per minute\n    newton = \"newton\" # force\n    joule = \"joule\" # energy\n    watt = \"watt\" # power\n    # temperature\n    celsius = \"celsius\"\n    kelvin = \"kelvin\"\n    # electricity\n    volt = \"volt\"\n    ampere = \"ampere\"\n    # light\n    lux = \"lux\"\n    # air\n    pascal = \"pascal\"\n    ppm = \"ppm\" # parts per million, air quality\n    # informatics\n    bytes = \"bytes\" # data size\n    bps = \"bps\" # bytes per second, data rate\n\nclass ParameterRole(StrEnum):\n    sensor = 'sensor' # get-only\n    control = 'control' # get-set\n    event = 'event'\n\nclass Parameter(UUIdentifable):\n    id: UUID\n    name: str\n    data_type: ParameterDataType\n    unit: ParameterUnit = ParameterUnit.plain\n    role: ParameterRole\n\n    # value constraints (value for nubmers, char length for string, byte length for data)\n    min_value: int | float | None = None\n    max_value: int | float | None = None\n    min_step: int | float | None = None\n\n    valid_values: dict[int | float | str, str] | None = None # value and string representation, mostly for enums\n\n    integration_data: Any\n\nclass ParameterState(Parameter):\n    value: bytes\n</code></pre>"},{"location":"api/bridge/","title":"Bridge API","text":""},{"location":"api/bridge/#open-full-page","title":"Open Full Page","text":""},{"location":"api/cloud/","title":"Cloud API","text":""},{"location":"api/cloud/#open-full-page","title":"Open Full Page","text":""},{"location":"api/hub/","title":"Hub API","text":""},{"location":"api/hub/#open-full-page","title":"Open Full Page","text":""},{"location":"api/dev/","title":"Index","text":""},{"location":"api/dev/#cloud","title":"Cloud","text":""},{"location":"api/dev/#bridge","title":"Bridge","text":""},{"location":"api/dev/#hub","title":"Hub","text":""},{"location":"api/dev/bridge/","title":"Bridge","text":""},{"location":"api/dev/bridge/#open-full-page","title":"Open Full Page","text":""},{"location":"api/dev/cloud/","title":"Cloud","text":""},{"location":"api/dev/cloud/#open-full-page","title":"Open Full Page","text":""},{"location":"api/dev/hub/","title":"Hub","text":""},{"location":"api/dev/hub/#open-full-page","title":"Open Full Page","text":""},{"location":"hub-development/how-to-start/","title":"How to Start","text":""},{"location":"hub-development/how-to-start/#usage","title":"Usage","text":"<p>Flash ready image from releases page to a SD card (or MMC/eMMC/SSD).</p>"},{"location":"hub-development/how-to-start/#develop-locally","title":"Develop Locally","text":""},{"location":"hub-development/how-to-start/#setup","title":"Setup","text":"<p>Clone the repo and cd to it</p> <p>Install dependencies <pre><code>pip install poetry \npoetry install\n</code></pre></p> <p>Generate token signing keys <pre><code>ssh-keygen -t rsa -b 4096 -m PEM -f cloud.key -N \"\"\nopenssl rsa -in cloud.key -pubout -outform PEM -out cloud.key.pub\nssh-keygen -t rsa -b 4096 -m PEM -f hub.key -N \"\"\nopenssl rsa -in hub.key -pubout -outform PEM -out hub.key.pub\n</code></pre></p> <p>Prepare .env <pre><code>cp example.env .env\n</code></pre></p> <p>Read CLI options <pre><code>poetry run python3 majordom_hub --help\n</code></pre></p> <p>Run <pre><code>poetry run python3 majordom_hub --virtual \n</code></pre></p>"}]}